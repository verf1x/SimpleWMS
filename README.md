# Simple WMS

### Содержание
- [Описание проекта](#описание-проекта)
- [Механика работы склада](#механика-работы-склада)
- [Термины](#Термины)
- [Идея процессов](#идея-процессов-на-складе)
- [Пример работы на складе](#пример-работы-на-складе)
- [Roadmap](#Roadmap)
- [Чего не хватает в самом API](#чего-не-хватает-в-самом-api)

### Описание проекта
Проект представляет собой простейший WMS (Warehouse Management System) для управления складом маркетплейса, написанный с использованием .NET 9.0 и ASP.NET Core Web API, SQL Server, EF Core, MediatR.

### Механика работы склада
Склад состоит из нескольких зон: зона приемки, две зоны хранения и зона отгрузки.
На приемке принимаются товары, которые затем распределяются по зонам хранения. Из зон хранения товары отгружаются в зону отгрузки, из которой они отгружаются либо на пункты выдачи заказов курьерами, либо отправляются на другие склады для дальнейшего распределения.

### Термины
- **Экземпляр** (**Instance**) - отдельная единица товара в отправлении (постинге)
- **Груз** (**Cargo**) - совокупность экземпляров/тарных ящиков, размещенных в одну оборотную тару - паллет
- **TD (TargetDestination)** - целевое место назначения - пункт прибытия перевозки/груза/отправления
- **Мобильный Контейнер** (МК) (**MobileContainer**)
- **Тарный ящик** (ТЯ) (**Crate**)
- **Sort** - мелкогабаритный товар, который хранится в ТЯ/МК в зависимости от субъективной оценки работника
- **Nonsort** - крупногабаритный/тяжелый товар, который хранится в МК/ТЯ в зависимости от субъективной оценки работника 

### Идея процессов на складе

#### Создание задач для нашего склада
- Еще до приезда машин с грузом, мы уже знаем о том, какие грузы к нам приедут. Мы знаем, какие экземпляры будут в них находиться, именно на этом этапе товары добавляются в бд, им выдаются места в МК и ТЯ, потому что заранее мы не знаем, куда поместится товар, так что сразу выделяем места в обоих контейнерах и устанавливаем статус на ожидается, который изменится уже только при приемке товара, что описано дальше. Из товаров, которые ожидаются на складе мы создаем задания, на создание грузов уже нашего склада, которые собираются из наших товаров. Админ может создать **этикетку перевозки** груза и наклеить ее на паллет с нашим грузом. Сначала груз имеет статус "Формируется", теперь работники склада могут просканировать этикетку опцией **"Наполнение груза"** и увидеть список экземпляров, которые нужно собрать в груз. Экземпляры из списка, которые имеют статус **"Принят, готов к размещению"** отображаются в списке вместе с данными о МК и ТЯ, где в одном из двух мест они могут находиться после размещения. Работник идет и берет любой товар из списка, сканирует в этой же опции, которая ожидает сканирование **этикетки отправления**, кладет товар в груз и еще раз в этой же опции сканирует этикетку перевозки этого груза, ему возвращается результат OK, в списке груза этот товар помечается как добавленный. Как только все товары добавлены, груз запечатывается опцией "Закрыть груз", в него больше невозможно добавлять товары, он получает статус "Собран"
#### Приемка
- Приезжает машина, в ней может быть **перевозка/ контейнер рейса, который заменяет перевозку.** Будем считать, что контейнер рейса едет по нескольким складам и привозит на каждый склад по маршруту грузы для этого склада. Мы получили грузы с соответствующими **этикетками перевозки груза** на них путем сканирования с помощью ТСД(в нашем случае какая-то заглушка) опцией меню **"Приемка груза из машины"**, которая ждет сканирование. Грузы добавляются в нашу бд для **принятых грузов**, где у груза есть его данные. Дальше грузы везутся на приемку товара из них, и там уже работник опцией **"Приемка из контейнера"**, которая требует сначала отсканировать **QRCode стола приемки**, а потом **этикетку перевозки груза**, начинает принимать товары путем сканирования **этикетки отправления**, которая наклеена на каждый экземпляр. При сканировании экземпляра на ТСД показывается надпись "Разместить в МК" и номер МК, который был присовен товару при создании задания на складе, и "разместить в ТЯ" с номером ТЯ, который так же присвоен в момент создания задания, статус экземпляра обновляется на **"Принят, готов к размещению"**, а так же экземпляру присваиваются все данные, полученные с этикетки отправления. Грузы будут двух типов: с **Sort** и **Nonsort** экземплярами. В нашем API будем считать, что товары разных категорий не могут встречаться в одном грузе вместе.
#### Размещение
- На складе принятые товары лежат в соответствующих местах, но складываются во время приемки они без использования API, это уже просто человеческая работа. Работники без API знают, откуда дальше эти экземпляры брать на размещение. Предположим, что далее работники находят принятый экземпляр, далее его нужно **разместить**: **Nonsort** размещается в **МК/ТЯ** в зависимости от габаритов, в нашей бд не будет информации о размерах экземплярах и весе, работники уже сами выбирают на глаз, куда разместить экземпляр. **Sort** размещается только в **ТЯ**, в общем работник на размещении сканирует товар опцией **"Размещение в МК"**, если считает экземпляр достаточно большим, либо опцией **"Размещение в ТЯ"**, если субъективно считает экземпляр слишком маленьким, при сканировании он получает соответствующий номер МК из задания склада, либо номер ТЯ из того же задания, куда этот экземпляр нужно разместить. Он подходит к соответствующему контейнеру и сканирует либо **QR-код МК**, либо **ШК ТЯ**, который наклеен на него. Если отсканированный номер в QR/ШК ТЯ/МК соответствуют тому, что находится в бд заданий склада, то статус экземпляра меняется на "Размещен" и в бд заданий и в бд всех товаров на складе. Если ТЯ заполнен, а это уже работник определяет сам, то он может специальной опцией просканировать ШК ТЯ, ведь на каждом есть специальный ШК, закрыть этот ТЯ этой кнопкой и у него в бд появится статус **"Собран"**, теперь при сканировании опцией "Размещение в МК" появится номер МК, в который нужно разместить собранный ТЯ

#### Выдача в машину или курьеру
- У нас есть какое-то количество собранных грузов, за ними приезжают машины для доставки на ПВЗ/ дальнейшей транспортировке на другие склады, эта информация генерируется при создании этикеток для наших грузов, дальше товар остается отсканировать курьеру/ водителю фуры опцией "Перевозка груза", остальное уже не является нашей ответственностью. Груз получает статус "Отправлен"

#### Опционально 
- Так же на складе нашего маркетплейса будет разделение товара на Marketplace(товар маркетплейса) и FBS (товар, который отправляется на наш склад со склада продавца), будет обработка возвратов и другие операции по мере расширения API. В дальнейшем можно будет расширить функциональнал для использования нашего API не только на обычном складе, но и в логистических центрах, крупных складах.

### Пример работы на складе
За создание грузов, создание перевозки и отправление на наш склад по-хорошему отвечает другой склад, но так как у нас нет другого склада, который отправит нам машину с перевозкой, создадим ее вручную:

- Сначала создадим несколько товаров, которые будут помещены в груз:
`POST /api/Instances/expected`
```json
[
  {
    "shippingNumber": "SHIP-00001234-0001",
    "sortType": "Sort"
  }
]
```
![img.png](swaggerscreenshots/img.png)
```json
[
  {
    "shippingNumber": "SHIP-00001234-0002",
    "sortType": "Sort"
  }
]
```
![img_1.png](swaggerscreenshots/img_1.png)
- Создадим груз, который будет содержать эти товары:
`POST /api/Cargo`
```json
{
  "cargoName": "Pallet A",
  "cargoBarcode": "CARGO-002"
}
```
![img_2.png](swaggerscreenshots/img_2.png)
- Добавим в груз товары:
`POST /api/Cargo/{id}/add-instance, в качестве id передаем Guid груза`
```json
{
  "instanceBarcode": "SHIP-00001234-0001"
}
```
![img_3.png](swaggerscreenshots/img_3.png)
```json
{
  "instanceBarcode": "SHIP-00001234-0002"
}
```
![img_4.png](swaggerscreenshots/img_4.png)
- Закроем груз:
`POST /api/Cargo/{id}/close`
![img_5.png](swaggerscreenshots/img_5.png)

- Создадим машину с перевозкой, которая будет содержать груз:
`POST /api/Transportation`
```json
{
  "transportationNumber": 1313,
  "routeA": "Moscow",
  "routeB": "Samara",
  "vehicleData": "А345УВ777",
  "shipmentDate": "2025-05-04"
}
```
![img_6.png](swaggerscreenshots/img_6.png)
- Привяжем груз к машине с перевозкой:
`POST /api/transportation/{transportationId}/cargo/{cargoId}`
- ![img_7.png](swaggerscreenshots/img_7.png)


- Примем созданную где-то перевозку на наш склад:
`POST /api/Receiving/transportation`
```json
{
  "transportationId": "25076f12-e454-42cd-a3ef-cac30854d732"
}
```
![img_8.png](swaggerscreenshots/img_8.png)

- Теперь примем груз из перевозки:
`POST /api/Receiving/cargo`
```json
{
  "cargoBarcode": "CARGO-002"
}
```
![img_9.png](swaggerscreenshots/img_9.png)
- Примем товар из груза отсканировав стол приемки и ШК товара:
`POST /api/Receiving/instance`
```json
{
  "instanceBarcode": "SHIP-00001234-0001",
  "tableQr": "TABLE-01"
}
```
![img_10.png](swaggerscreenshots/img_10.png)
- Разместим товар в зоне хранения:
- Для этого создадим мобильный контейнер
`POST /api/MobileContainer`
```json
{
  "number": "1-1"
}
```
![img_11.png](swaggerscreenshots/img_11.png)

- Поместим сам товар в него
`POST /api/Placement/mc`
```json
{
  "instanceBarcode": "SHIP-00001234-0001",
  "mcNumber": "1-1"
}
```
![img_12.png](swaggerscreenshots/img_12.png)
- Теперь допустим мы разместили множество товаров на нашем складе, нам нужно их отгрузить.
- Для этого создадим груз нашего склада
`POST /api/Cargo`
```json
{
  "cargoName": "Pallet B",
  "cargoBarcode": "CARGO-003"
}
```
![img_13.png](swaggerscreenshots/img_13.png)
- Добавим в груз товар:
`POST /api/Cargo/{id}/add-instance`
```json
{
  "instanceBarcode": "SHIP-00001234-0001"
}
```
![img_14.png](swaggerscreenshots/img_14.png)
- Закрываем груз:
`POST /api/Cargo/{id}/close`
- ![img_15.png](swaggerscreenshots/img_15.png)

- Отправляем груз на отгрузку:
`POST /api/Shipping/cargo/{cargoId}`
- ![img_16.png](swaggerscreenshots/img_16.png)

- У нас остался непринятый товар, примем его:
  `POST /api/Receiving/instance`
```json
{
  "instanceBarcode": "SHIP-00001234-0002",
  "tableQr": "TABLE-01"
}
```
![img_17.png](swaggerscreenshots/img_17.png)
- Разместим его в зоне хранения уже в тарный ящик:
- Для этого создадим его
`POST /api/Crate`
```json
{
  "locationCode": "A-1-3_2"
}
```
![img_18.png](swaggerscreenshots/img_18.png)
- Поместим товар в него
`POST /api/Placement/crate`
```json
{
  "instanceBarcode": "SHIP-00001234-0002",
  "crateCode": "A-1-3_2"
}
```
![img_19.png](swaggerscreenshots/img_19.png)
- Теперь допустим мы разместили множество товаров в тарный ящик, закроем его и разместим в мобильный контейнер.
- Закрываем тарный ящик:
`POST /api/Crate/close/{id}`
![img_20.png](swaggerscreenshots/img_20.png)
- Размещаем в мобильный контейнер:
`POST /api/Crate/{id}/move-to-mc`
```json
{
  "mcNumber": "1-1"
}
```
![img_21.png](swaggerscreenshots/img_21.png)
- Создадим груз из нашего тарного ящика
- Для этого создадим груз
`POST /api/Cargo`
```json
{
  "cargoName": "Pallet D",
  "cargoBarcode": "CARGO-008"
}
```
![img_22.png](swaggerscreenshots/img_22.png)
- Поместим в него тарный ящик
`POST /api/Cargo/{id}/add-crate`
```json
{
  "crateId": "1b78a51e-10f7-4ec6-970a-a37d9698d048"
}
```
![img_23.png](swaggerscreenshots/img_23.png)
- Закрываем груз:
- `POST /api/Cargo/{id}/close`
- ![img_24.png](swaggerscreenshots/img_24.png)

- Отправляем груз на отгрузку:
- `POST /api/Shipping/cargo/{cargoId}`
- ![img_25.png](swaggerscreenshots/img_25.png)

### Roadmap
- [x] Создание грузов для доставки на наш склад
- [x] Наполнение грузов для отправки на наш склад
- [x] Приемка грузов на наш склад
- [x] Приемка товаров из груза
- [x] Размещение товаров на складе в МК
- [x] Размещение товаров на складе в ТЯ
- [x] Закрытие ТЯ
- [x] Перемещение ТЯ в МК
- [x] Создание грузов для отгрузки с нашего склада
- [x] Наполнение грузов для отгрузки с нашего склада
- [x] Отгрузка грузов с нашего склада
- [x] Заглушка для ТСД (Терминал Сбора Данных) в виде строковой работы с QR-кодами и ШК
- [] Создание перевозки для отправки с нашего склада
- [] Выбор отгрузки на ПВЗ или на другой склад
- [] Генерация заданий на создание и наполнение наших грузов

### Чего не хватает в самом API:
- Четкой валидации
- Отсутствует валидация на уровне базы данных
- Отсутствует адекватная авторизация
- Не хватает проверок при выполнении операций
- Есть несостыковки в названиях
- Фикс багов с позициями ТЯ и МК
- Слабая работа с бд, так как очень мало опыта
- В целом пока слабо понимаю, как правильно проектировать Web API, поэтому вышло криво-косо
